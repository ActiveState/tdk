# Copyright (c) 2018 ActiveState Software Inc.
# Released under the BSD-3 license. See LICENSE file for details.
#
package provide HttpUtils 1.0

proc Trace {{skip 1}} {
    set result {}
    for {set level [expr [info level] - $skip]} {$level >= 0} {incr level -1} {
	lappend result [info level $level]
    }
    return $result
}

proc narrate {args} {
    #return
    set sf [info level -1]
    puts stderr "N: $args: $sf"
}

set ::debug 10

proc Debug {message {level 1}} {
    upvar 1 debug debug
    if {[info exists debug]} {
    } else {
	upvar \#0 debug debug
    }
    upvar 1 self self

    if {$debug >= $level} {
	if {[info exists self]} {
	    puts stderr "$self: [uplevel 1 subst [list $message]]"
	} else {
	    puts stderr "[uplevel 1 subst [list $message]]"
	}
    }
}

# translation -- 
#
#	fconfigure the connected socket into a given mode
#
# Arguments:
#	args	additional args to fconfigure
#
# Side Effects:
#	sets the connected socket to the given mode

proc translation {sock args} {
    set additional {}
    for {set i 0} {$i < [llength $args]} {incr i} {
	set a [lindex $args $i]
	switch -glob -- $a {
	    -r* {
		incr i
		set rmode [lindex $args $i]
	    }
	    -w* {
		incr i
		set wmode [lindex $args $i]
	    }
	    default {
		lappend additional $a
	    }
	}
    }

    foreach {crm cwm} [fconfigure $sock -translation] break

    if {[info exists rmode] && ($crm ne $rmode)} {
	#puts stderr "$sock read mode to $rmode"
    } else {
	set rmode $crm
    }

    if {[info exists wmode] && ($cwm ne $wmode)} {
	#puts stderr "$sock write mode to $wmode"
    } else {
	set wmode $cwm
    }

    eval [linsert $additional 0 fconfigure $sock -translation [list $rmode $wmode]]
    #puts stderr "MODE: $rmode $wmode"
}

##interp bgerror "" ::http::bgerror

namespace eval http {
    proc narrate {args} {
	return
	set sf [info level -1]
	upvar -1 self self
	$self log debug "N: $args: $sf"
    }

    # throw --
    #
    #
    # Arguments:
    #
    #	dict	request dict
    #	msg	error message
    #	code	http error code
    #
    # Results: None
    #
    # Side Effects:
    #
    #	transforms a protocol error into a tcl error with attached
    #	-request dictionary, used to feed errors back to client

    proc throw {dict msg {code 500}} {
	return -code $code $msg
    }

    # trap background errors generated by requests
    proc bgerror {message eo} {
	puts stderr "bgerror: $message ($eo)"
	if {[dict exists $eo -request]} {
	    # this is a request error
	    
	    # decode arg
	    set code 500
	    foreach arg $args {
		if {[string is integer -strict $arg]} {
		    set code $arg
		} else {
		    set message $arg
		}
	    }
	    
	    # set the informational error message
	    if {![info exists message] || ($message eq "")} {
		set message [::http::ErrorMsg $code]
	    }
	    
	    $self log info "Error: $self $code - '$message'"
	    
	    # create a response
	    uplevel 1 $self [list Respond $trx [list $code $message] [list "" "
<html>
<title>Error: $code</title>
<body>
<h1>Error $code</h1>
<p>$message</p>
</body>
</html>
" Content-Type text/html]]
	} else {
	    # this is a normal error
	    #::tcl::Bgerror $message $eo
	    puts stderr "BGERROR: $message - ($eo)"
	}
    }

    # HTTP error codes and default textual interpretation
    variable Errors
    array set Errors {
	1 "Informational - Request received, continuing process"
	100 Continue
	101 "Switching Protocols"

	2 "Success - received, understood, and accepted"
	200 OK
	201 Created
	202 Accepted
	203 "Non-Authoritative Information"
	204 "No Content"
	205 "Reset Content"
	206 "Partial Content"

	3 "Redirection - Further action needed"
	300 "Multiple Choices"
	301 "Moved Permanently"
	302 "Found"
	303 "See Other"
	304 "Not Modified"
	305 "Use Proxy"
	307 "Temporary Redirect"

	4 "Client Error - request bad or cannot be fulfilled"
	400 "Bad Request"
	401 "Unauthorized"
	402 "Payment Required"
	403 "Forbidden"
	404 "Not Found"
	405 "Method Not Allowed"
	406 "Not Acceptable"
	407 "Proxy Authentication Required"
	408 "Request Time-out"
	409 "Conflict"
	410 "Gone"
	411 "Length Required"
	412 "Precondition Failed"
	413 "Request Entity Too Large"
	414 "Request-URI Too Large"
	415 "Unsupported Media Type"
	416 "Requested range not satisfiable"
	417 "Expectation Failed"

	5 "Server Error - Server failed to fulfill an apparently valid request"
	500 "Internal Server Error"
	501 "Not Implemented"
	502 "Bad Gateway"
	503 "Service Unavailable"
	504 "Gateway Time-out"
	505 "HTTP Version not supported"
    }

    variable headers
    foreach n {accept accept-charset accept-encoding accept-language authorization expect from host if-match if-modified-since if-none-match if-range if-unmodified-since max-forwards proxy-authorization referer te user-agent} {
	set headers($n) rq
    }

    foreach n {accept-ranges age etag location proxy-authenticate retry-after server vary www-authenticate} {
	set headers($n) rs
    }

    foreach n {allow content-encoding content-language content-length content-location content-md5 content-range content-type expires last-modified} {
	set headers($n) e
    }

    foreach n {cache-control connection date pragma trailer transfer-encoding upgrade via warning} {
	set headers($n) e
    }

    # map http error code to human readable message
    proc ErrorMsg {code} {
	variable Errors
	if {[info exist Errors($code)]} {
	    return $Errors($code)
	} else {
	    return "Error $code"
	}
    }

    # return an http date
    proc Date {seconds} {
	return [clock format $seconds \
		    -format {%a, %d %b %Y %T GMT} \
		    -gmt true]
    }

    # normalize -- 
    #
    #	collapse and normalize //, ../ and . components to avoid tricks
    #	like //cgi-bin that fail to match the /cgi-bin prefix
    #	and ../ that escape domains
    #
    # Arguments:
    #	args	url to normalize
    #
    # Results:
    #	normalized url
    #
    # Side Effects:
    #	none

    proc normalize {url} {
	while {[set new [regsub -all {(/+)|(^[.][.]/)|(^/[.][.])|(/[^/]+/[.][.]$)|(/[^/]+/[.][.]/)|(^[.]/)|(/[.]$)|(/[.]/)|(^[.][.]$)|(^[.]$)} $url /]] ne $url} {
	    set url $new
	}
	return "/[string trim $url /]"
    }

    # urlparse -- 
    #
    #	parse a url into its constituent parts
    #
    # Arguments:
    #	args	url to parse
    #
    # Results:
    #	array form of parsed URL elements
    #
    # Side Effects:
    #	none

    proc urlparse {url} {
	array set x {}
	regexp {^(([^:/?\#]+):)?(//([^/?\#]*))?([^?\#]*)([?]([^\#]*))?(\#(.*))?$} $url \
	    -> . x(-scheme) . x(-authority) x(-path) . x(-query) . x(-fragment)
	regexp {^(([^@]+)@)?([^@:]+)?(:([0-9]+))?$} $x(-authority) \
	    -> . x(-authority) x(-host) . x(-port)
	
	set x(-path) [normalize $x(-path)]	;# fix up oddities in URLs

	foreach n [array names x] {
	    if {$x($n) eq ""} {
		unset x($n)
	    }
	}

	if {[info exists x(-scheme)]} {
	    set x(-url) [Http genURL [array get x]]
	}

	#puts stderr "urlparse: $url -> [array get x]"
	return [array get x]
    }

    proc genURL {x} {
	foreach {part pre post} {
	    -scheme "" :
	    -host // ""
	    -port : ""
	    -path "" ""
	} {
	    if {[dict exists $x $part]} {
		append result "${pre}[dict get $x $part]${post}"
	    }
	}
	return $result
    }

    proc genURI {x} {
	set result [::http::genURL $x]
	foreach {part pre post} {
	    -fragment \# ""
	    -query ? ""
	} {
	    if {[dict exists $x $part]} {
		append result "${pre}[dict get $x $part]${post}"
	    }
	}
	return $result
    }
}
